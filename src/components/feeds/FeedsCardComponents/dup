import {
  View,
  Text,
  ScrollView,
  ActivityIndicator,
  NativeSyntheticEvent,
  TextInputKeyPressEventData,
} from "react-native";
import React, { useEffect } from "react";
import Box from "../../general/Box";
import { FlatList, TextInput } from "react-native-gesture-handler";
import CustomButton from "../../general/CustomButton";
import { useTheme } from "@shopify/restyle";
import { Theme } from "../../../theme";
import { Ionicons } from "@expo/vector-icons";
import {
  ImagePickerAsset,
  launchImageLibraryAsync,
  MediaTypeOptions,
  UIImagePickerPresentationStyle,
} from "expo-image-picker";
import { Image } from "expo-image";
import ImageBox from "./ImageBox";
import CommentTextBox from "./CommentTextBox";
import CommentCard from "./CommentCard";
import {
  useInfiniteQuery,
  useMutation,
  useQuery,
  useQueryClient,
} from "react-query";
import httpService from "../../../utils/httpService";
import { URLS } from "../../../services/urls";
import useToast from "../../../hooks/useToast";
import { IComment } from "../../../models/comments";
import CustomText from "../../general/CustomText";
import useCheckLoggedInState from "../../../hooks/useCheckLoggedInState";
import mime from "mime";
import { PaginatedResponse } from "../../../models/PaginatedResponse";
import { CUSTOM_STATUS_CODE } from "../../../enums/CustomCodes";
import _ from "lodash";
import { useCommentMentionState } from "../commentState";

const CommentSection = ({ postId }: { postId?: number }) => {
  const theme = useTheme<Theme>();
  const [images, setImages] = React.useState<ImagePickerAsset[]>([]);
  const [text, setText] = React.useState("");
  const [comments, setComments] = React.useState<Array<IComment>>([]);
  const [currentPage, setCurrentPage] = React.useState(1);
  const [total, setTotal] = React.useState(0);
  const [ids, setIds] = React.useState<number[]>([]);
  const [perPage, setPerPage] = React.useState(0);
  const [noMore, setNoMore] = React.useState(false);

  const toast = useToast();
  const queryClient = useQueryClient();
  const { checkloggedInState } = useCheckLoggedInState();
  const [fetchMore, setFetchMore] = React.useState(false);

  const { users, selectedUsers, reset } = useCommentMentionState(
    (state) => state
  );

  //queries

  const {
    isError,
    isLoading: isLoadingComments,
    data,
    refetch,
    hasNextPage,
    fetchNextPage,
    isFetchingNextPage,
    isFetching,
  } = useInfiniteQuery({
    queryKey: [`fetch_comments`, postId],
    queryFn: ({ pageParam = 1 }) =>
      httpService.get(
        `${URLS.GET_COMMENTS_BY_POST_ID}/${postId}?page=${pageParam}`
      ),
    getNextPageParam: (_lastpage, allPages) => {
      const currentPage = allPages[allPages.length - 1];
      if (currentPage.data.data.next_page_url) {
        return allPages.length + 1;
      } else {
        return undefined;
      }
    },
    onSuccess: () => {
      setFetchMore(false);
    },
    onError: (e: any) => {
      if (e.code !== CUSTOM_STATUS_CODE.NO_DATA) {
        toast.show(e.message, { type: "danger" });
      }
    },
  });

  useEffect(() => {
    if (Array.isArray(data?.pages) && data.pages[0].data.data) {
      console.log(data.pages, "pagess");
      // item.data.data.data
      const theComments = data.pages.map((item) => item?.data?.data?.data);

      console.log(theComments, "ss");
      let allDataFromPages = [];
      for (let i = 0; i < theComments.length; i++) {
        allDataFromPages = [...allDataFromPages, ...theComments[i]];
      }

      setComments([...allDataFromPages]);
    }
  }, [data, data?.pages]);

  const { mutate, isLoading: mutationLoading } = useMutation({
    mutationFn: (data: FormData) =>
      httpService.post(`${URLS.CREATE_COMMENT}`, data),
    onSuccess: (res) => {
      toast.show("Comment created successfully", { type: "success" });
      console.log(res.data, "res.data");
      setComments([
        {
          ...res.data?.data,
          user: res.data.user,
          post_images: [],
          has_reacted: [],
          has_downvoted: 0,
          has_upvoted: 0,
          replies_count: 0,
          reactions_count: 0,
          upvotes_count: 0,
          downvotes_count: 0,
        },
        ...comments,
      ]);
      // refetch();
      // refetch({ refetchPage: (page, index) => index === 0 });
      // queryClient.invalidateQueries([`fetch_comments`, postId]);
      // queryClient.invalidateQueries([`fetch_comments`]);
      // queryClient.invalidateQueries([`getPostComments-${postId}`]);
      // queryClient.invalidateQueries([`getPost${postId}`]);
      setImages([]);
      setText("");
      reset();
    },
    onError: (error: any) => {
      toast.show("An error occured while trying to create the comment", {
        type: "error",
      });
    },
  });

  const handleTextChange = React.useCallback(
    (coment: string) => {
      // do regex to gext mentioned users
      const check = checkloggedInState();
      if (check) {
        setText(coment);
      }
    },
    [checkloggedInState]
  );

  const handleEnterKeyPressed = React.useCallback(
    (e: NativeSyntheticEvent<TextInputKeyPressEventData>) => {
      if (e.nativeEvent.key === "enter") {
        handleSubmit();
      }
    },
    []
  );

  const handleSubmit = React.useCallback(() => {
    if (mutationLoading) return;
    const formData = new FormData();
    formData.append("post_id", postId.toString() as any);
    const newText = text.replace(/@\[([^\]]*)\]\(\)/g, "@$1");
    formData.append("comment", newText);
    if (images.length > 0) {
      for (let i = 0; i < images.length; i++) {
        const name = images[i].uri.split("/").pop();
        const mimeType = mime.getType(images[i].uri);
        formData.append("comment_images[]", {
          uri: images[i].uri,
          type: mimeType,
          name,
        } as any);
      }
    }
    const regex = /@\[\w+/g;
    const mentionss = text.match(regex) || [];
    const userIds: number[] = [];
    mentionss.forEach((item) => {
      const newItem = item.replace("[", "");

      const user = selectedUsers.map((user) => {
        if (
          user.name.toLowerCase().includes(newItem.toLowerCase().substring(1))
        ) {
          userIds.push(user.id);

          //formData.append('mentioned_users', user.id.toString())
          return user.id;
        }
      });
    });

    formData.append("mentioned_users[]", userIds as any);
    mutate(formData);
  }, [text, postId, mutationLoading]);

  const handleImagePicked = (image: ImagePickerAsset) => {
    if (images.length > 0) {
      return;
    } else {
      setImages((prevImages) => [...prevImages, image]);
    }
  };

  const removeImage = (index: number) => {
    const newImages = images.filter((item, i) => i !== index);
    setImages(newImages);
  };

  return (
    <Box
      width="100%"
      minHeight={50}
      bg="mainBackGroundColor"
      position="relative"
    >
      <Box
        flex={1}
        maxHeight={600}
        paddingTop="s"
        borderTopWidth={0.3}
        marginHorizontal="m"
      >
        <FlatList
          // extraData={comments}
          ListEmptyComponent={() => (
            <>
              {!isLoadingComments && (
                <Box
                  width={"100%"}
                  height={50}
                  justifyContent={"center"}
                  alignItems={"center"}
                >
                  <CustomText variant="subheader" fontSize={14}>
                    No comment. Be the first to comment on this post
                  </CustomText>
                </Box>
              )}
            </>
          )}
          ListFooterComponent={() => (
            <>
              {(isLoadingComments || isFetching || isFetchingNextPage) && (
                <Box
                  width={"100%"}
                  height={"100%"}
                  justifyContent="center"
                  alignItems="center"
                >
                  <ActivityIndicator
                    size={"large"}
                    color={theme.colors.primaryColor}
                  />
                </Box>
              )}
            </>
          )}
          onScrollBeginDrag={() => {
            if (hasNextPage) {
              setFetchMore(true);
            }
          }}
          onEndReachedThreshold={0.5}
          onEndReached={async () => {
            if (
              fetchMore &&
              hasNextPage &&
              (!isFetching || !isFetchingNextPage)
            ) {
              await fetchNextPage();
            }
          }}
          keyExtractor={(item, index) => index.toString()}
          // data={
          //   Array.isArray(data?.pages) && data.pages[0].data.data
          //     ? data?.pages
          //     : []
          // }
          data={comments}
          renderItem={({ item }) => {
            return <CommentCard comment={item} />;
          }}
          // renderItem={({ item }) => {
          //   console.log(item, "helppp");
          //   // return <></>;
          //   return item.data.data.data.map((item: IComment) => (
          //     <CommentCard comment={item} />
          //   ));
          //   // <CommentCard comment={item} />
          // }}
        />
      </Box>

      <Box
        width="100%"
        minHeight={90}
        bg="mainBackGroundColor"
        overflow="visible"
        elevation={4}
        borderTopWidth={0.3}
        borderTopColor="lightGrey"
        paddingVertical="s"
        paddingHorizontal="m"
      >
        {images.length > 0 && (
          <Box width="100%" height={90}>
            <ScrollView
              style={{ width: "100%", flex: 1 }}
              contentContainerStyle={{
                justifyContent: "center",
                alignItems: "center",
              }}
              horizontal
            >
              {images.map((item, index) => (
                <ImageBox
                  key={index.toString()}
                  type="LOCAL"
                  payload={item}
                  index={index}
                  onRemove={removeImage}
                />
              ))}
            </ScrollView>
          </Box>
        )}
        <CommentTextBox
          onSubmit={() => handleSubmit()}
          isLoading={mutationLoading}
          text={text}
          onTextChange={(e) => handleTextChange(e)}
          onImagePicked={handleImagePicked}
        />
      </Box>
    </Box>
  );
};

export default CommentSection;
